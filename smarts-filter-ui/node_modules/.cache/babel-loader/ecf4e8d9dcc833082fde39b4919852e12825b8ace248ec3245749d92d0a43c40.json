{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n      const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      setPainsChecked(painsIsChecked);\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES for PAINS:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n      if (painsIsChecked) {\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n        const resultList = [];\n        json.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            if (entry.failed) {\n              var _entry$highlight_atom, _entry$highlight_atom2;\n              const highlightIndices = (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [];\n              resultList.push({\n                name: entry.name || inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: \"PAINS\",\n                matched: true,\n                failed: true,\n                highlightAtoms: highlightIndices\n              });\n            } else {\n              resultList.push({\n                name: entry.name || inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: \"PAINS\",\n                matched: false,\n                failed: false,\n                highlightAtoms: []\n              });\n            }\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n\n        // Sort with failed on top\n        resultList.sort((a, b) => Number(b.failed) - Number(a.failed));\n        setResults(resultList);\n        return;\n      }\n\n      // Default SMARTS logic (non-PAINS)\n      let smartsRaw = \"\";\n      if (inputData.smarts && inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else if (inputData.smarts) {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n      const smartsArray = smartsRaw.split(/\\n+/).map(line => line.trim()).filter(Boolean).map(line => {\n        const parts = line.split(/\\s+/);\n        return {\n          smarts: parts[0],\n          name: parts[1] || `S${Math.random().toString(36).slice(2, 6)}`\n        };\n      });\n      if (mode === \"normal\" && runmode === \"filter\") {\n        const allResults = [];\n        for (let i = 0; i < smartsArray.length; i++) {\n          var _json$failed, _json$passed;\n          const query = new URLSearchParams();\n          query.append(\"SMILES\", smilesArray.join(\",\"));\n          query.append(\"Smile_Names\", namesArray.join(\",\"));\n          query.append(\"smarts\", smartsArray[i].smarts);\n          const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_matchfilter?${query}`);\n          const json = await res.json();\n          (_json$failed = json.failed) === null || _json$failed === void 0 ? void 0 : _json$failed.forEach(m => {\n            try {\n              const mol = RDKit.get_mol(m.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n              allResults.push({\n                name: inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: smartsArray[i].name,\n                matched: true,\n                failed: true\n              });\n            } catch {}\n          });\n          (_json$passed = json.passed) === null || _json$passed === void 0 ? void 0 : _json$passed.forEach(m => {\n            try {\n              const mol = RDKit.get_mol(m.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n              allResults.push({\n                name: inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: smartsArray[i].name,\n                matched: false,\n                failed: false\n              });\n            } catch {}\n          });\n        }\n        setResults(allResults);\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setDepict: setDepict,\n    setPainsChecked: setPainsChecked,\n    view: view,\n    depict: depict,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      depict: depict\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 215,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ZVeM/VDWQEHu6bfUEueg8WUZAyM=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","App","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","depict","setDepict","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","smilesRaw","smiles","type","content","lines","split","filter","Boolean","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","warn","query","URLSearchParams","append","join","res","fetch","json","resultList","entry","failed","_entry$highlight_atom","_entry$highlight_atom2","highlightIndices","highlight_atoms","flat","name","get","SMILES","Smart","matched","highlightAtoms","sort","a","b","Number","smartsRaw","smarts","smartsArray","map","trim","Math","random","toString","slice","allResults","i","_json$failed","_json$passed","m","passed","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/App.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport InputData from \"./components/InputData\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n};\n\nfunction App() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\n  const handleSubmit = async (inputData: any) => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      const smilesArray: string[] = [];\n      const namesArray: string[] = [];\n\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      setPainsChecked(painsIsChecked);\n\n      const inputCanonMap = new Map<string, string>();\n      const inputNameMap = new Map<string, string>();\n\n      await new Promise<void>((resolve) => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES for PAINS:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n\n      if (painsIsChecked) {\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n        const resultList: MatchResult[] = [];\n\n        json.forEach((entry: any) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            if (entry.failed) {\n              const highlightIndices = entry.highlight_atoms?.flat() ?? [];\n              resultList.push({\n                name: entry.name || inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: \"PAINS\",\n                matched: true,\n                failed: true,\n                highlightAtoms: highlightIndices,\n              });\n            } else {\n              resultList.push({\n                name: entry.name || inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: \"PAINS\",\n                matched: false,\n                failed: false,\n                highlightAtoms: [],\n              });\n            }\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n\n        // Sort with failed on top\n        resultList.sort((a, b) => Number(b.failed) - Number(a.failed));\n        setResults(resultList);\n        return;\n      }\n\n      // Default SMARTS logic (non-PAINS)\n      let smartsRaw = \"\";\n      if (inputData.smarts && inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else if (inputData.smarts) {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n\n      const smartsArray = smartsRaw\n        .split(/\\n+/)\n        .map((line) => line.trim())\n        .filter(Boolean)\n        .map((line) => {\n          const parts = line.split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || `S${Math.random().toString(36).slice(2, 6)}`,\n          };\n        });\n\n      if (mode === \"normal\" && runmode === \"filter\") {\n        const allResults: MatchResult[] = [];\n\n        for (let i = 0; i < smartsArray.length; i++) {\n          const query = new URLSearchParams();\n          query.append(\"SMILES\", smilesArray.join(\",\"));\n          query.append(\"Smile_Names\", namesArray.join(\",\"));\n          query.append(\"smarts\", smartsArray[i].smarts);\n\n          const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_matchfilter?${query}`);\n          const json = await res.json();\n\n          json.failed?.forEach((m: any) => {\n            try {\n              const mol = RDKit.get_mol(m.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n              allResults.push({\n                name: inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: smartsArray[i].name,\n                matched: true,\n                failed: true,\n              });\n            } catch {}\n          });\n\n          json.passed?.forEach((m: any) => {\n            try {\n              const mol = RDKit.get_mol(m.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n              allResults.push({\n                name: inputNameMap.get(canon) || canon,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: smartsArray[i].name,\n                matched: false,\n                failed: false,\n              });\n            } catch {}\n          });\n        }\n\n        setResults(allResults);\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      setDepict={setDepict}\n      setPainsChecked={setPainsChecked}\n      view={view}\n      depict={depict}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        depict={depict}\n      />\n    </SmartFilterLayout>\n  );\n}\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}