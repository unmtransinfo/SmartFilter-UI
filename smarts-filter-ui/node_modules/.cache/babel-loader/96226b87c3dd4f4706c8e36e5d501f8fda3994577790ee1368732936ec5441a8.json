{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n      const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      console.log(smilesArray);\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      setPainsChecked(painsIsChecked);\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      // === PAINS Filter ===\n      if (painsIsChecked) {\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n        json.forEach(entry => {\n          try {\n            var _entry$highlight_atom, _entry$highlight_atom2;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const highlightIndices = (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [];\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: \"PAINS\",\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: highlightIndices\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // === Blake Filter (using get_matchfilter + ursu_pains.sma) ===\n      // === Blake Filter (using get_multi_matchfilter + ursu_pains.sma) ===\n      if (blakeIsChecked) {\n        var _json$failed, _json$passed;\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n        const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"unknown\"\n          };\n        });\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        query.append(\"smarts\", smartsPatterns.map(p => p.smarts).join(\",\"));\n        query.append(\"Smart_Names\", smartsPatterns.map(p => p.name).join(\",\"));\n        console.log(namesArray);\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchfilter?${query}`);\n        const json = await res.json();\n        (_json$failed = json.failed) === null || _json$failed === void 0 ? void 0 : _json$failed.forEach(entry => {\n          try {\n            var _entry$highlight_atom3, _entry$highlight_atom4;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reason || \"Blake\",\n              matched: true,\n              failed: true,\n              highlightAtoms: (_entry$highlight_atom3 = (_entry$highlight_atom4 = entry.highlight_atoms) === null || _entry$highlight_atom4 === void 0 ? void 0 : _entry$highlight_atom4.flat()) !== null && _entry$highlight_atom3 !== void 0 ? _entry$highlight_atom3 : []\n            });\n          } catch {}\n        });\n        (_json$passed = json.passed) === null || _json$passed === void 0 ? void 0 : _json$passed.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reason || \"Blake\",\n              matched: false,\n              failed: false,\n              highlightAtoms: []\n            });\n          } catch {}\n        });\n      }\n\n      // === If no filters checked, fallback to normal SMARTS input filter ===\n      if (!painsIsChecked && !blakeIsChecked) {\n        let smartsRaw = \"\";\n        if (inputData.smarts && inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else if (inputData.smarts) {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n        const smartsArray = smartsRaw.split(/\\n+/).map(line => line.trim()).filter(Boolean).map(line => {\n          const parts = line.split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || `S${Math.random().toString(36).slice(2, 6)}`\n          };\n        });\n        if (mode === \"normal\" && runmode === \"filter\") {\n          for (let i = 0; i < smartsArray.length; i++) {\n            var _json$failed2, _json$passed2;\n            const query = new URLSearchParams();\n            query.append(\"SMILES\", smilesArray.join(\",\"));\n            query.append(\"Smile_Names\", namesArray.join(\",\"));\n            query.append(\"smarts\", smartsArray[i].smarts);\n            const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_matchfilter?${query}`);\n            const json = await res.json();\n            (_json$failed2 = json.failed) === null || _json$failed2 === void 0 ? void 0 : _json$failed2.forEach(m => {\n              try {\n                const mol = RDKit.get_mol(m.smiles);\n                const canon = mol.get_smiles();\n                mol.delete();\n                combinedResults.push({\n                  name: inputNameMap.get(canon) || canon,\n                  SMILES: inputCanonMap.get(canon) || canon,\n                  Smart: smartsArray[i].name,\n                  matched: true,\n                  failed: true\n                });\n              } catch {}\n            });\n            (_json$passed2 = json.passed) === null || _json$passed2 === void 0 ? void 0 : _json$passed2.forEach(m => {\n              try {\n                const mol = RDKit.get_mol(m.smiles);\n                const canon = mol.get_smiles();\n                mol.delete();\n                combinedResults.push({\n                  name: inputNameMap.get(canon) || canon,\n                  SMILES: inputCanonMap.get(canon) || canon,\n                  Smart: smartsArray[i].name,\n                  matched: false,\n                  failed: false\n                });\n              } catch {}\n            });\n          }\n        }\n      }\n\n      // Sort so failed are on top\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setDepict: setDepict,\n    setPainsChecked: setPainsChecked,\n    view: view,\n    depict: depict,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      depict: depict\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 268,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ZVeM/VDWQEHu6bfUEueg8WUZAyM=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","App","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","depict","setDepict","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","smilesRaw","smiles","type","content","lines","split","filter","Boolean","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","warn","combinedResults","query","URLSearchParams","append","join","res","fetch","json","entry","_entry$highlight_atom","_entry$highlight_atom2","highlightIndices","highlight_atoms","flat","name","get","SMILES","Smart","matched","failed","highlightAtoms","_json$failed","_json$passed","smartsText","then","text","smartsPatterns","trim","map","smarts","p","_entry$highlight_atom3","_entry$highlight_atom4","reason","passed","smartsRaw","smartsArray","Math","random","toString","slice","i","_json$failed2","_json$passed2","m","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/App.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport InputData from \"./components/InputData\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n};\n\nfunction App() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\n  const handleSubmit = async (inputData: any) => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n\n    try {\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      const smilesArray: string[] = [];\n      const namesArray: string[] = [];\n\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      console.log(smilesArray)\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      setPainsChecked(painsIsChecked);\n\n      const inputCanonMap = new Map<string, string>();\n      const inputNameMap = new Map<string, string>();\n\n      await new Promise<void>((resolve) => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n\n      let combinedResults: MatchResult[] = [];\n      // === PAINS Filter ===\n      if (painsIsChecked) {\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n\n        json.forEach((entry: any) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n\n            const highlightIndices = entry.highlight_atoms?.flat() ?? [];\n\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: \"PAINS\",\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: highlightIndices,\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // === Blake Filter (using get_matchfilter + ursu_pains.sma) ===\n// === Blake Filter (using get_multi_matchfilter + ursu_pains.sma) ===\n      if (blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n        const smartsPatterns = smartsText\n          .split(/\\r?\\n/)\n          .filter(line => line.trim().length > 0)\n          .map(line => {\n            const parts = line.trim().split(/\\s+/);\n            return { smarts: parts[0], name: parts[1] || \"unknown\" };\n          });\n\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        query.append(\"smarts\", smartsPatterns.map(p => p.smarts).join(\",\"));\n        query.append(\"Smart_Names\", smartsPatterns.map(p => p.name).join(\",\"));\n          console.log(namesArray)\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchfilter?${query}`);\n        const json = await res.json();\n\n        json.failed?.forEach((entry: any) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reason || \"Blake\",\n              matched: true,\n              failed: true,\n              highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n            });\n          } catch {}\n        });\n\n        json.passed?.forEach((entry: any) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n\n            combinedResults.push({\n              name: entry.name || inputNameMap.get(canon) || canon,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reason || \"Blake\",\n              matched: false,\n              failed: false,\n              highlightAtoms: [],\n            });\n          } catch {}\n        });\n      }\n\n\n      // === If no filters checked, fallback to normal SMARTS input filter ===\n      if (!painsIsChecked && !blakeIsChecked) {\n        let smartsRaw = \"\";\n        if (inputData.smarts && inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else if (inputData.smarts) {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n\n        const smartsArray = smartsRaw\n          .split(/\\n+/)\n          .map((line) => line.trim())\n          .filter(Boolean)\n          .map((line) => {\n            const parts = line.split(/\\s+/);\n            return {\n              smarts: parts[0],\n              name: parts[1] || `S${Math.random().toString(36).slice(2, 6)}`,\n            };\n          });\n\n        if (mode === \"normal\" && runmode === \"filter\") {\n          for (let i = 0; i < smartsArray.length; i++) {\n            const query = new URLSearchParams();\n            query.append(\"SMILES\", smilesArray.join(\",\"));\n            query.append(\"Smile_Names\", namesArray.join(\",\"));\n            query.append(\"smarts\", smartsArray[i].smarts);\n\n            const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_matchfilter?${query}`);\n            const json = await res.json();\n\n            json.failed?.forEach((m: any) => {\n              try {\n                const mol = RDKit.get_mol(m.smiles);\n                const canon = mol.get_smiles();\n                mol.delete();\n\n                combinedResults.push({\n                  name: inputNameMap.get(canon) || canon,\n                  SMILES: inputCanonMap.get(canon) || canon,\n                  Smart: smartsArray[i].name,\n                  matched: true,\n                  failed: true,\n                });\n              } catch {}\n            });\n\n            json.passed?.forEach((m: any) => {\n              try {\n                const mol = RDKit.get_mol(m.smiles);\n                const canon = mol.get_smiles();\n                mol.delete();\n\n                combinedResults.push({\n                  name: inputNameMap.get(canon) || canon,\n                  SMILES: inputCanonMap.get(canon) || canon,\n                  Smart: smartsArray[i].name,\n                  matched: false,\n                  failed: false,\n                });\n              } catch {}\n            });\n          }\n        }\n      }\n\n      // Sort so failed are on top\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n\n      setResults(combinedResults);\n\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      setDepict={setDepict}\n      setPainsChecked={setPainsChecked}\n      view={view}\n      depict={depict}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        depict={depict}\n      />\n    </SmartFilterLayout>\n  );\n}\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}