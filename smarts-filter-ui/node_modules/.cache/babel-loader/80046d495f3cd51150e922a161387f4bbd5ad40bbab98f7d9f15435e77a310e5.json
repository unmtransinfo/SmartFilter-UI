{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction HomePage() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n  const [errorMessage, setErrorMessage] = useState([]);\n  const addError = msg => {\n    setErrorMessage(prev => [...prev, msg]);\n  };\n  const safeFetch = async url => {\n    const res = await fetch(url);\n    if (!res.ok) {\n      const text = await res.text().catch(() => \"\");\n      throw new Error(`Request failed (${res.status}): ${text || url}`);\n    }\n    return res.json();\n  };\n  useEffect(() => {\n    const handler = e => {\n      var _e$reason;\n      setErrorMessage(((_e$reason = e.reason) === null || _e$reason === void 0 ? void 0 : _e$reason.message) || \"Unexpected error.\");\n    };\n    window.addEventListener(\"unhandledrejection\", handler);\n    return () => window.removeEventListener(\"unhandledrejection\", handler);\n  }, []);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      var _inputData$config$has, _inputData$config, _inputData$smarts, _inputData$smarts$con;\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      // Skip header if hasHeader true\n      const hasHeader = (_inputData$config$has = (_inputData$config = inputData.config) === null || _inputData$config === void 0 ? void 0 : _inputData$config.hasHeader) !== null && _inputData$config$has !== void 0 ? _inputData$config$has : false;\n      let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      if (hasHeader) {\n        lines = lines.slice(1); // Skip first line (header)\n      }\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      const isExpert = mode === \"expert\";\n      setPainsChecked(painsIsChecked);\n\n      // Cache canonical smiles and names\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch (err) {\n              addError(\"Error 400 Invalid Smiles\" + smilesArray[idx]);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      // Helper to append expert params\n      const appendExpertParams = query => {\n        if (typeof excludeMolProps === \"boolean\") query.append(\"ExcludeMolProp\", excludeMolProps ? \"true\" : \"false\");\n        if (typeof strictMode === \"boolean\") query.append(\"strict_error\", strictMode ? \"true\" : \"false\");\n        if (typeof uniqueAtoms === \"boolean\") query.append(\"unique_set\", uniqueAtoms ? \"true\" : \"false\");\n        if (typeof useKekule === \"boolean\") query.append(\"kekuleSmiles\", useKekule ? \"true\" : \"false\");\n        if (typeof useIsomeric === \"boolean\") query.append(\"isomericSmiles\", useIsomeric ? \"true\" : \"false\");\n        if (typeof non_zero_row === \"boolean\") query.append(\"only_rows\", non_zero_row ? \"true\" : \"false\");\n      };\n\n      // PAINS Filter API call (only excludeMolProps)\n      if (runmode === \"filter\" && painsIsChecked) {\n        var _inputData$config2;\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        if ((_inputData$config2 = inputData.config) !== null && _inputData$config2 !== void 0 && _inputData$config2.excludeMolProps) {\n          query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        }\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        if (res.status != 200) {\n          addError(\"Error\" + res.status + res.statusText);\n        }\n        const json = await res.json();\n        json.results.forEach(entry => {\n          try {\n            var _entry$highlight_atom, _entry$highlight_atom2;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reasons.join(\", \"),\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [],\n              all_pains_filters: json.all_pains_filters,\n              matches: json.all_pains_filters.map(p => entry.reasons.includes(p)),\n              filterName: \"PAINS\"\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // BLAKE Filter API call with expert params\n      if (runmode === \"filter\" && blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(r => {\n          if (!r.ok) throw new Error(`Could not read /data/ursu_pains.sma (${r.status})`);\n          return r.text();\n        });\n        const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"unknown\"\n          };\n        });\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        smartsPatterns.forEach(s => {\n          query.append(\"smarts\", s.smarts);\n          query.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(query);\n        const json = await safeFetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n        json.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom;\n              return (_match$highlight_atom = match.highlight_atoms) !== null && _match$highlight_atom !== void 0 ? _match$highlight_atom : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: smartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"BLAKE\"\n            });\n          } catch {\n            console.warn(\"Failed to process BLAKE entry:\", entry);\n          }\n        });\n      }\n\n      // Expert Custom SMARTS mode\n      if (isExpert && (_inputData$smarts = inputData.smarts) !== null && _inputData$smarts !== void 0 && (_inputData$smarts$con = _inputData$smarts.content) !== null && _inputData$smarts$con !== void 0 && _inputData$smarts$con.trim()) {\n        let smartsRaw = \"\";\n        if (inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n        const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n        const customSmartsPatterns = customSmartsLines.map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"custom\"\n          };\n        });\n        const expertQuery = new URLSearchParams();\n        expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n        expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n        customSmartsPatterns.forEach(s => {\n          expertQuery.append(\"smarts\", s.smarts);\n          expertQuery.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(expertQuery);\n        const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n        const expertJson = await expertRes.json();\n        expertJson.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom2;\n              return (_match$highlight_atom2 = match.highlight_atoms) !== null && _match$highlight_atom2 !== void 0 ? _match$highlight_atom2 : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: customSmartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"CUSTOM\"\n            });\n          } catch {\n            console.warn(\"Failed to process EXPERT entry:\", entry);\n          }\n        });\n      }\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setPainsChecked: setPainsChecked,\n    batch: batch,\n    view: view,\n    includePasses: includePasses,\n    setIncludePasses: setIncludePasses,\n    includeFails: includeFails,\n    setIncludeFails: setIncludeFails,\n    hasHeader: hasHeader,\n    setHasHeader: setHasHeader,\n    excludeMolProps: excludeMolProps,\n    setExcludeMolProps: setExcludeMolProps,\n    strictMode: strictMode,\n    setStrictMode: setStrictMode,\n    non_zero_row: non_zero_row,\n    setNonZeroRows: setNonZeroRows,\n    uniqueAtoms: uniqueAtoms,\n    setUniqueAtoms: setUniqueAtoms,\n    useKekule: useKekule,\n    setUseKekule: setUseKekule,\n    useIsomeric: useIsomeric,\n    setUseIsomeric: setUseIsomeric,\n    errorMessage: errorMessage,\n    setErrorMessage: setErrorMessage,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      includePasses: includePasses,\n      includeFails: includeFails\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 357,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 325,\n    columnNumber: 5\n  }, this);\n}\n_s(HomePage, \"bio6yOAVJjXn2ycR4S/NpYXdzVM=\");\n_c = HomePage;\nexport default HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","HomePage","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","includePasses","setIncludePasses","includeFails","setIncludeFails","hasHeader","setHasHeader","excludeMolProps","setExcludeMolProps","strictMode","setStrictMode","non_zero_row","setNonZeroRows","uniqueAtoms","setUniqueAtoms","useKekule","setUseKekule","useIsomeric","setUseIsomeric","errorMessage","setErrorMessage","addError","msg","prev","safeFetch","url","res","fetch","ok","text","catch","Error","status","json","handler","e","_e$reason","reason","message","window","addEventListener","removeEventListener","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","_inputData$config$has","_inputData$config","_inputData$smarts","_inputData$smarts$con","smilesRaw","smiles","type","content","config","lines","split","filter","Boolean","slice","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","isExpert","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","combinedResults","appendExpertParams","query","append","_inputData$config2","URLSearchParams","join","statusText","entry","_entry$highlight_atom","_entry$highlight_atom2","name","SMILES","get","Smart","reasons","matched","failed","highlightAtoms","highlight_atoms","flat","all_pains_filters","matches","map","p","filterName","warn","smartsText","then","r","smartsPatterns","trim","smarts","s","isFailed","some","match","count","highlightAtomsFlat","flatMap","_match$highlight_atom","x","uniqueHighlightAtoms","Array","from","Set","matchBooleans","m","smartsRaw","customSmartsLines","customSmartsPatterns","expertQuery","expertRes","expertJson","_match$highlight_atom2","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n  all_pains_filters?: string[];\n  filterName?: string;\n};\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nfunction HomePage() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n  const [errorMessage, setErrorMessage] = useState<string[]>([]);\n  const addError = (msg: string) => {\n  setErrorMessage((prev) => [...prev, msg]);\n};\n\n\n  const safeFetch = async (url: string) => {\n    const res = await fetch(url);\n    if (!res.ok) {\n      const text = await res.text().catch(() => \"\");\n      throw new Error(`Request failed (${res.status}): ${text || url}`);\n    }\n    return res.json();\n  };\n  useEffect(() => {\n    const handler = (e: PromiseRejectionEvent) => {\n      setErrorMessage(e.reason?.message || \"Unexpected error.\");\n    };\n    window.addEventListener(\"unhandledrejection\", handler);\n    return () => window.removeEventListener(\"unhandledrejection\", handler);\n  }, []);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\nconst handleSubmit = async (inputData: any) => {\n  if (isSubmitting) return;\n  setIsSubmitting(true);\n\n  try {\n    let smilesRaw = \"\";\n    if (inputData.smiles.type === \"text\") {\n      smilesRaw = inputData.smiles.content;\n    } else {\n      smilesRaw = await readFileContent(inputData.smiles.content);\n    }\n\n    // Skip header if hasHeader true\n    const hasHeader = inputData.config?.hasHeader ?? false;\n    let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n    if (hasHeader) {\n      lines = lines.slice(1); // Skip first line (header)\n    }\n\n    const smilesArray: string[] = [];\n    const namesArray: string[] = [];\n    for (const line of lines) {\n      const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n      const smile = parts[inputData.smileCol] || \"\";\n      smilesArray.push(smile);\n      namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n    }\n\n    setMatch(smilesArray.length);\n    const painsIsChecked = inputData.filters.includes(\"Pains\");\n    const blakeIsChecked = inputData.filters.includes(\"Blake\");\n    const isExpert = mode === \"expert\";\n    setPainsChecked(painsIsChecked);\n\n    // Cache canonical smiles and names\n    const inputCanonMap = new Map<string, string>();\n    const inputNameMap = new Map<string, string>();\n    \n    await new Promise<void>((resolve) => {\n      requestIdleCallback(() => {\n        smilesArray.forEach((smi, idx) => {\n          try {\n            const mol = RDKit.get_mol(smi);\n            const canon = mol.get_smiles();\n            mol.delete();\n            inputCanonMap.set(canon, smi);\n            inputNameMap.set(canon, namesArray[idx]);\n          } catch(err) {\n            addError(\"Error 400 Invalid Smiles\"+smilesArray[idx]);\n          }\n        });\n        resolve();\n      });\n    });\n\n    let combinedResults: MatchResult[] = [];\n    // Helper to append expert params\n    const appendExpertParams = (query: URLSearchParams) => {\n      if (typeof excludeMolProps === \"boolean\")\n        query.append(\"ExcludeMolProp\", excludeMolProps ? \"true\" : \"false\");\n      if (typeof strictMode === \"boolean\")\n        query.append(\"strict_error\", strictMode ? \"true\" : \"false\");\n      if (typeof uniqueAtoms === \"boolean\")\n        query.append(\"unique_set\", uniqueAtoms ? \"true\" : \"false\");\n      if (typeof useKekule === \"boolean\")\n        query.append(\"kekuleSmiles\", useKekule ? \"true\" : \"false\");\n      if (typeof useIsomeric === \"boolean\")\n        query.append(\"isomericSmiles\", useIsomeric ? \"true\" : \"false\");\n      if (typeof non_zero_row === \"boolean\")\n          query.append(\"only_rows\", non_zero_row ? \"true\" : \"false\");\n    };\n\n    // PAINS Filter API call (only excludeMolProps)\n    if (runmode === \"filter\" && painsIsChecked) {\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      if (inputData.config?.excludeMolProps) {\n        query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      }\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n      if(res.status !=200){\n        addError(\"Error\"+res.status+res.statusText)\n      }\n      const json = await res.json();\n      json.results.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.reasons.join(\", \"),\n            matched: entry.failed,\n            failed: entry.failed,\n            highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n            all_pains_filters: json.all_pains_filters,\n            matches: json.all_pains_filters.map((p: string) => entry.reasons.includes(p)),\n            filterName: \"PAINS\",\n          });\n        } catch {\n          console.warn(\"Failed to process PAINS entry:\", entry);\n        }\n      });\n    }\n\n    // BLAKE Filter API call with expert params\n    if (runmode === \"filter\" && blakeIsChecked) {\n      const smartsText = await fetch(\"/data/ursu_pains.sma\").then(r => {\n        if (!r.ok) throw new Error(`Could not read /data/ursu_pains.sma (${r.status})`);\n        return r.text();\n      });\n      \n      const smartsPatterns = smartsText\n        .split(/\\r?\\n/)\n        .filter((line) => line.trim().length > 0)\n        .map((line) => {\n          const parts = line.trim().split(/\\s+/);\n          return { smarts: parts[0], name: parts[1] || \"unknown\" };\n        });\n\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      smartsPatterns.forEach((s) => {\n        query.append(\"smarts\", s.smarts);\n        query.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(query);\n\n      const json = await safeFetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n      json.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans: boolean[] = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: smartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"BLAKE\",\n          });\n        } catch {\n          console.warn(\"Failed to process BLAKE entry:\", entry);\n        }\n      });\n    }\n\n    // Expert Custom SMARTS mode\n    if (isExpert && inputData.smarts?.content?.trim()) {\n      let smartsRaw = \"\";\n      if (inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n\n      const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter((line: string) => line.trim().length > 0);\n      const customSmartsPatterns = customSmartsLines.map((line: string) => {\n        const parts = line.trim().split(/\\s+/);\n        return { smarts: parts[0], name: parts[1] || \"custom\" };\n      });\n\n      const expertQuery = new URLSearchParams();\n      expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n      expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n      customSmartsPatterns.forEach((s) => {\n        expertQuery.append(\"smarts\", s.smarts);\n        expertQuery.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(expertQuery);\n\n      const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n      const expertJson = await expertRes.json();\n      expertJson.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: customSmartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"CUSTOM\",\n          });\n        } catch {\n          console.warn(\"Failed to process EXPERT entry:\", entry);\n        }\n      });\n    }\n\n    combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n    setResults(combinedResults);\n  } finally {\n    setIsSubmitting(false);\n  }\n};\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      setPainsChecked={setPainsChecked}\n      batch={batch}\n      view={view}\n      includePasses={includePasses}\n      setIncludePasses={setIncludePasses}\n      includeFails={includeFails}\n      setIncludeFails={setIncludeFails}\n      hasHeader = {hasHeader}\n      setHasHeader={setHasHeader}\n      excludeMolProps={excludeMolProps}\n      setExcludeMolProps={setExcludeMolProps}\n      strictMode={strictMode}\n      setStrictMode={setStrictMode}\n      non_zero_row={non_zero_row}\n      setNonZeroRows={setNonZeroRows}\n      uniqueAtoms={uniqueAtoms}\n      setUniqueAtoms={setUniqueAtoms}\n      useKekule={useKekule}\n      setUseKekule={setUseKekule}\n      useIsomeric={useIsomeric}\n      setUseIsomeric={setUseIsomeric}\n      errorMessage={errorMessage}\n      setErrorMessage={setErrorMessage}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        includePasses={includePasses}\n        includeFails={includeFails}\n      />\n    </SmartFilterLayout>\n  );\n}\n\nexport default HomePage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}