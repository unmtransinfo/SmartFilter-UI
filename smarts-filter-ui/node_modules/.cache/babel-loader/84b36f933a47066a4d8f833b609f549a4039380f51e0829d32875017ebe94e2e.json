{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction HomePage() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      var _inputData$config$has, _inputData$config, _inputData$smarts, _inputData$smarts$con;\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      // Skip header if hasHeader true\n      const hasHeader = (_inputData$config$has = (_inputData$config = inputData.config) === null || _inputData$config === void 0 ? void 0 : _inputData$config.hasHeader) !== null && _inputData$config$has !== void 0 ? _inputData$config$has : false;\n      let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      if (hasHeader) {\n        lines = lines.slice(1); // Skip first line (header)\n      }\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      const isExpert = mode === \"expert\";\n      setPainsChecked(painsIsChecked);\n\n      // Cache canonical smiles and names\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      console.log(inputData);\n      // Helper to append expert params\n      const appendExpertParams = query => {\n        if (!inputData.config) return;\n        if (typeof inputData.config.excludeMolProps === \"boolean\") query.append(\"ExcludeMolProp\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        if (typeof inputData.config.strictMode === \"boolean\") query.append(\"strict_error\", inputData.config.strictMode ? \"true\" : \"false\");\n        if (typeof inputData.config.uniqueAtoms === \"boolean\") query.append(\"unique_set\", inputData.config.uniqueAtoms ? \"true\" : \"false\");\n        if (typeof inputData.config.kekule === \"boolean\") query.append(\"kekuleSmiles\", inputData.config.kekule ? \"true\" : \"false\");\n        if (typeof inputData.config.isomeric === \"boolean\") query.append(\"isomericSmiles\", inputData.config.isomeric ? \"true\" : \"false\");\n        if (typeof inputData.config.non_zero_row === \"boolean\") query.append(\"only_rows\", inputData.config.non_zero_row ? \"true\" : \"false\");\n      };\n\n      // PAINS Filter API call (only excludeMolProps)\n      if (runmode === \"filter\" && painsIsChecked) {\n        var _inputData$config2;\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        if ((_inputData$config2 = inputData.config) !== null && _inputData$config2 !== void 0 && _inputData$config2.excludeMolProps) {\n          query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        }\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n        json.results.forEach(entry => {\n          try {\n            var _entry$highlight_atom, _entry$highlight_atom2;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reasons.join(\", \"),\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [],\n              all_pains_filters: json.all_pains_filters,\n              matches: json.all_pains_filters.map(p => entry.reasons.includes(p)),\n              filterName: \"PAINS\"\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // BLAKE Filter API call with expert params\n      if (runmode === \"filter\" && blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n        const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"unknown\"\n          };\n        });\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        smartsPatterns.forEach(s => {\n          query.append(\"smarts\", s.smarts);\n          query.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(query);\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n        const json = await res.json();\n        json.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom;\n              return (_match$highlight_atom = match.highlight_atoms) !== null && _match$highlight_atom !== void 0 ? _match$highlight_atom : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: smartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"BLAKE\"\n            });\n          } catch {\n            console.warn(\"Failed to process BLAKE entry:\", entry);\n          }\n        });\n      }\n\n      // Expert Custom SMARTS mode\n      if (isExpert && (_inputData$smarts = inputData.smarts) !== null && _inputData$smarts !== void 0 && (_inputData$smarts$con = _inputData$smarts.content) !== null && _inputData$smarts$con !== void 0 && _inputData$smarts$con.trim()) {\n        let smartsRaw = \"\";\n        if (inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n        const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n        const customSmartsPatterns = customSmartsLines.map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"custom\"\n          };\n        });\n        const expertQuery = new URLSearchParams();\n        expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n        expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n        customSmartsPatterns.forEach(s => {\n          expertQuery.append(\"smarts\", s.smarts);\n          expertQuery.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(expertQuery);\n        const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n        const expertJson = await expertRes.json();\n        expertJson.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom2;\n              return (_match$highlight_atom2 = match.highlight_atoms) !== null && _match$highlight_atom2 !== void 0 ? _match$highlight_atom2 : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: customSmartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"CUSTOM\"\n            });\n          } catch {\n            console.warn(\"Failed to process EXPERT entry:\", entry);\n          }\n        });\n      }\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setPainsChecked: setPainsChecked,\n    batch: batch,\n    view: view,\n    includePasses: includePasses,\n    setIncludePasses: setIncludePasses,\n    includeFails: includeFails,\n    setIncludeFails: setIncludeFails,\n    hasHeader: hasHeader,\n    setHasHeader: setHasHeader,\n    excludeMolProps: excludeMolProps,\n    setExcludeMolProps: setExcludeMolProps,\n    strictMode: strictMode,\n    setStrictMode: setStrictMode,\n    non_zero_row: non_zero_row,\n    setNonZeroRows: setNonZeroRows,\n    uniqueAtoms: uniqueAtoms,\n    setUniqueAtoms: setUniqueAtoms,\n    useKekule: useKekule,\n    setUseKekule: setUseKekule,\n    useIsomeric: useIsomeric,\n    setUseIsomeric: setUseIsomeric,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      includePasses: includePasses,\n      includeFails: includeFails\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 334,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 304,\n    columnNumber: 5\n  }, this);\n}\n_s(HomePage, \"y3aDB3DRG16uMBARjHMPLDFK6MU=\");\n_c = HomePage;\nexport default HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","HomePage","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","includePasses","setIncludePasses","includeFails","setIncludeFails","hasHeader","setHasHeader","excludeMolProps","setExcludeMolProps","strictMode","setStrictMode","non_zero_row","setNonZeroRows","uniqueAtoms","setUniqueAtoms","useKekule","setUseKekule","useIsomeric","setUseIsomeric","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","_inputData$config$has","_inputData$config","_inputData$smarts","_inputData$smarts$con","smilesRaw","smiles","type","content","config","lines","split","filter","Boolean","slice","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","isExpert","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","warn","combinedResults","appendExpertParams","query","append","kekule","isomeric","_inputData$config2","URLSearchParams","join","res","fetch","json","entry","_entry$highlight_atom","_entry$highlight_atom2","name","SMILES","get","Smart","reasons","matched","failed","highlightAtoms","highlight_atoms","flat","all_pains_filters","matches","map","p","filterName","smartsText","then","text","smartsPatterns","trim","smarts","s","isFailed","some","match","count","highlightAtomsFlat","flatMap","_match$highlight_atom","x","uniqueHighlightAtoms","Array","from","Set","matchBooleans","m","smartsRaw","customSmartsLines","customSmartsPatterns","expertQuery","expertRes","expertJson","_match$highlight_atom2","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n  all_pains_filters?: string[];\n  filterName?: string;\n};\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nfunction HomePage() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\nconst handleSubmit = async (inputData: any) => {\n  if (isSubmitting) return;\n  setIsSubmitting(true);\n\n  try {\n    let smilesRaw = \"\";\n    if (inputData.smiles.type === \"text\") {\n      smilesRaw = inputData.smiles.content;\n    } else {\n      smilesRaw = await readFileContent(inputData.smiles.content);\n    }\n\n    // Skip header if hasHeader true\n    const hasHeader = inputData.config?.hasHeader ?? false;\n    let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n    if (hasHeader) {\n      lines = lines.slice(1); // Skip first line (header)\n    }\n\n    const smilesArray: string[] = [];\n    const namesArray: string[] = [];\n    for (const line of lines) {\n      const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n      const smile = parts[inputData.smileCol] || \"\";\n      smilesArray.push(smile);\n      namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n    }\n\n    setMatch(smilesArray.length);\n    const painsIsChecked = inputData.filters.includes(\"Pains\");\n    const blakeIsChecked = inputData.filters.includes(\"Blake\");\n    const isExpert = mode === \"expert\";\n    setPainsChecked(painsIsChecked);\n\n    // Cache canonical smiles and names\n    const inputCanonMap = new Map<string, string>();\n    const inputNameMap = new Map<string, string>();\n\n    await new Promise<void>((resolve) => {\n      requestIdleCallback(() => {\n        smilesArray.forEach((smi, idx) => {\n          try {\n            const mol = RDKit.get_mol(smi);\n            const canon = mol.get_smiles();\n            mol.delete();\n            inputCanonMap.set(canon, smi);\n            inputNameMap.set(canon, namesArray[idx]);\n          } catch {\n            console.warn(\"Invalid SMILES:\", smi);\n          }\n        });\n        resolve();\n      });\n    });\n\n    let combinedResults: MatchResult[] = [];\n    console.log(inputData)\n    // Helper to append expert params\n    const appendExpertParams = (query: URLSearchParams) => {\n      if (!inputData.config) return;\n      if (typeof inputData.config.excludeMolProps === \"boolean\")\n        query.append(\"ExcludeMolProp\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      if (typeof inputData.config.strictMode === \"boolean\")\n        query.append(\"strict_error\", inputData.config.strictMode ? \"true\" : \"false\");\n      if (typeof inputData.config.uniqueAtoms === \"boolean\")\n        query.append(\"unique_set\", inputData.config.uniqueAtoms ? \"true\" : \"false\");\n      if (typeof inputData.config.kekule === \"boolean\")\n        query.append(\"kekuleSmiles\", inputData.config.kekule ? \"true\" : \"false\");\n      if (typeof inputData.config.isomeric === \"boolean\")\n        query.append(\"isomericSmiles\", inputData.config.isomeric ? \"true\" : \"false\");\n      if (typeof inputData.config.non_zero_row === \"boolean\")\n          query.append(\"only_rows\", inputData.config.non_zero_row ? \"true\" : \"false\");\n    };\n\n    // PAINS Filter API call (only excludeMolProps)\n    if (runmode === \"filter\" && painsIsChecked) {\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      if (inputData.config?.excludeMolProps) {\n        query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      }\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n      const json = await res.json();\n\n      json.results.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.reasons.join(\", \"),\n            matched: entry.failed,\n            failed: entry.failed,\n            highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n            all_pains_filters: json.all_pains_filters,\n            matches: json.all_pains_filters.map((p: string) => entry.reasons.includes(p)),\n            filterName: \"PAINS\",\n          });\n        } catch {\n          console.warn(\"Failed to process PAINS entry:\", entry);\n        }\n      });\n    }\n\n    // BLAKE Filter API call with expert params\n    if (runmode === \"filter\" && blakeIsChecked) {\n      const smartsText = await fetch(\"/data/ursu_pains.sma\").then((res) => res.text());\n      const smartsPatterns = smartsText\n        .split(/\\r?\\n/)\n        .filter((line) => line.trim().length > 0)\n        .map((line) => {\n          const parts = line.trim().split(/\\s+/);\n          return { smarts: parts[0], name: parts[1] || \"unknown\" };\n        });\n\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      smartsPatterns.forEach((s) => {\n        query.append(\"smarts\", s.smarts);\n        query.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(query);\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n      const json = await res.json();\n\n      json.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans: boolean[] = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: smartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"BLAKE\",\n          });\n        } catch {\n          console.warn(\"Failed to process BLAKE entry:\", entry);\n        }\n      });\n    }\n\n    // Expert Custom SMARTS mode\n    if (isExpert && inputData.smarts?.content?.trim()) {\n      let smartsRaw = \"\";\n      if (inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n\n      const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter((line: string) => line.trim().length > 0);\n      const customSmartsPatterns = customSmartsLines.map((line: string) => {\n        const parts = line.trim().split(/\\s+/);\n        return { smarts: parts[0], name: parts[1] || \"custom\" };\n      });\n\n      const expertQuery = new URLSearchParams();\n      expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n      expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n      customSmartsPatterns.forEach((s) => {\n        expertQuery.append(\"smarts\", s.smarts);\n        expertQuery.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(expertQuery);\n\n      const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n      const expertJson = await expertRes.json();\n\n      expertJson.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: customSmartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"CUSTOM\",\n          });\n        } catch {\n          console.warn(\"Failed to process EXPERT entry:\", entry);\n        }\n      });\n    }\n\n    combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n    setResults(combinedResults);\n  } finally {\n    setIsSubmitting(false);\n  }\n};\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      setPainsChecked={setPainsChecked}\n      batch={batch}\n      view={view}\n      includePasses={includePasses}\n      setIncludePasses={setIncludePasses}\n      includeFails={includeFails}\n      setIncludeFails={setIncludeFails}\n      hasHeader = {hasHeader}\n      setHasHeader={setHasHeader}\n      excludeMolProps={excludeMolProps}\n      setExcludeMolProps={setExcludeMolProps}\n      strictMode={strictMode}\n      setStrictMode={setStrictMode}\n      non_zero_row={non_zero_row}\n      setNonZeroRows={setNonZeroRows}\n      uniqueAtoms={uniqueAtoms}\n      setUniqueAtoms={setUniqueAtoms}\n      useKekule={useKekule}\n      setUseKekule={setUseKekule}\n      useIsomeric={useIsomeric}\n      setUseIsomeric={setUseIsomeric}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        includePasses={includePasses}\n        includeFails={includeFails}\n      />\n    </SmartFilterLayout>\n  );\n}\n\nexport default HomePage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}