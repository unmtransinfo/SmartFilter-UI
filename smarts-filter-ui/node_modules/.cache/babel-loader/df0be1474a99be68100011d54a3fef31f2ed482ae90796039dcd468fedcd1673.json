{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction HomePage() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      var _inputData$config$has, _inputData$config, _inputData$smarts, _inputData$smarts$con;\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      // Skip header if hasHeader true\n      const hasHeader = (_inputData$config$has = (_inputData$config = inputData.config) === null || _inputData$config === void 0 ? void 0 : _inputData$config.hasHeader) !== null && _inputData$config$has !== void 0 ? _inputData$config$has : false;\n      let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      if (hasHeader) {\n        lines = lines.slice(1); // Skip first line (header)\n      }\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      const isExpert = mode === \"expert\";\n      setPainsChecked(painsIsChecked);\n\n      // Cache canonical smiles and names\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      console.log(inputData);\n      // Helper to append expert params\n      const appendExpertParams = query => {\n        if (!inputData.config) return;\n        if (typeof inputData.config.excludeMolProps === \"boolean\") query.append(\"ExcludeMolProp\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        if (typeof inputData.config.strictMode === \"boolean\") query.append(\"strict_error\", inputData.config.strictMode ? \"true\" : \"false\");\n        if (typeof inputData.config.uniqueAtoms === \"boolean\") query.append(\"unique_set\", inputData.config.uniqueAtoms ? \"true\" : \"false\");\n        if (typeof inputData.config.kekule === \"boolean\") query.append(\"kekuleSmiles\", inputData.config.kekule ? \"true\" : \"false\");\n        if (typeof inputData.config.isomeric === \"boolean\") query.append(\"isomericSmiles\", inputData.config.isomeric ? \"true\" : \"false\");\n        if (typeof inputData.config.non_zero_row === \"boolean\") query.append(\"only_rows\", inputData.config.non_zero_row ? \"true\" : \"false\");\n      };\n\n      // PAINS Filter API call (only excludeMolProps)\n      if (runmode === \"filter\" && painsIsChecked) {\n        var _inputData$config2;\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        if ((_inputData$config2 = inputData.config) !== null && _inputData$config2 !== void 0 && _inputData$config2.excludeMolProps) {\n          query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        }\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n        json.results.forEach(entry => {\n          try {\n            var _entry$highlight_atom, _entry$highlight_atom2;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reasons.join(\", \"),\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [],\n              all_pains_filters: json.all_pains_filters,\n              matches: json.all_pains_filters.map(p => entry.reasons.includes(p)),\n              filterName: \"PAINS\"\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // BLAKE Filter API call with expert params\n      if (runmode === \"filter\" && blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n        const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"unknown\"\n          };\n        });\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        smartsPatterns.forEach(s => {\n          query.append(\"smarts\", s.smarts);\n          query.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(query);\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n        const json = await res.json();\n        json.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom;\n              return (_match$highlight_atom = match.highlight_atoms) !== null && _match$highlight_atom !== void 0 ? _match$highlight_atom : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: smartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"BLAKE\"\n            });\n          } catch {\n            console.warn(\"Failed to process BLAKE entry:\", entry);\n          }\n        });\n      }\n\n      // Expert Custom SMARTS mode\n      if (isExpert && (_inputData$smarts = inputData.smarts) !== null && _inputData$smarts !== void 0 && (_inputData$smarts$con = _inputData$smarts.content) !== null && _inputData$smarts$con !== void 0 && _inputData$smarts$con.trim()) {\n        let smartsRaw = \"\";\n        if (inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n        const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n        const customSmartsPatterns = customSmartsLines.map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"custom\"\n          };\n        });\n        const expertQuery = new URLSearchParams();\n        expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n        expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n        customSmartsPatterns.forEach(s => {\n          expertQuery.append(\"smarts\", s.smarts);\n          expertQuery.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(expertQuery);\n        const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n        const expertJson = await expertRes.json();\n        expertJson.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom2;\n              return (_match$highlight_atom2 = match.highlight_atoms) !== null && _match$highlight_atom2 !== void 0 ? _match$highlight_atom2 : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: customSmartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"CUSTOM\"\n            });\n          } catch {\n            console.warn(\"Failed to process EXPERT entry:\", entry);\n          }\n        });\n      }\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setPainsChecked: setPainsChecked,\n    batch: batch,\n    view: view,\n    includePasses: includePasses,\n    setIncludePasses: setIncludePasses,\n    includeFails: includeFails,\n    setIncludeFails: setIncludeFails,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      includePasses: includePasses,\n      includeFails: includeFails\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 311,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 295,\n    columnNumber: 5\n  }, this);\n}\n_s(HomePage, \"2DMTXztBaP++JTFIITm/gHYZkFM=\");\n_c = HomePage;\nexport default HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","HomePage","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","includePasses","setIncludePasses","includeFails","setIncludeFails","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","_inputData$config$has","_inputData$config","_inputData$smarts","_inputData$smarts$con","smilesRaw","smiles","type","content","hasHeader","config","lines","split","filter","Boolean","slice","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","isExpert","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","warn","combinedResults","appendExpertParams","query","excludeMolProps","append","strictMode","uniqueAtoms","kekule","isomeric","non_zero_row","_inputData$config2","URLSearchParams","join","res","fetch","json","entry","_entry$highlight_atom","_entry$highlight_atom2","name","SMILES","get","Smart","reasons","matched","failed","highlightAtoms","highlight_atoms","flat","all_pains_filters","matches","map","p","filterName","smartsText","then","text","smartsPatterns","trim","smarts","s","isFailed","some","match","count","highlightAtomsFlat","flatMap","_match$highlight_atom","x","uniqueHighlightAtoms","Array","from","Set","matchBooleans","m","smartsRaw","customSmartsLines","customSmartsPatterns","expertQuery","expertRes","expertJson","_match$highlight_atom2","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n  all_pains_filters?: string[];\n  filterName?: string;\n};\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nfunction HomePage() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n\n\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\nconst handleSubmit = async (inputData: any) => {\n  if (isSubmitting) return;\n  setIsSubmitting(true);\n\n  try {\n    let smilesRaw = \"\";\n    if (inputData.smiles.type === \"text\") {\n      smilesRaw = inputData.smiles.content;\n    } else {\n      smilesRaw = await readFileContent(inputData.smiles.content);\n    }\n\n    // Skip header if hasHeader true\n    const hasHeader = inputData.config?.hasHeader ?? false;\n    let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n    if (hasHeader) {\n      lines = lines.slice(1); // Skip first line (header)\n    }\n\n    const smilesArray: string[] = [];\n    const namesArray: string[] = [];\n    for (const line of lines) {\n      const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n      const smile = parts[inputData.smileCol] || \"\";\n      smilesArray.push(smile);\n      namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n    }\n\n    setMatch(smilesArray.length);\n    const painsIsChecked = inputData.filters.includes(\"Pains\");\n    const blakeIsChecked = inputData.filters.includes(\"Blake\");\n    const isExpert = mode === \"expert\";\n    setPainsChecked(painsIsChecked);\n\n    // Cache canonical smiles and names\n    const inputCanonMap = new Map<string, string>();\n    const inputNameMap = new Map<string, string>();\n\n    await new Promise<void>((resolve) => {\n      requestIdleCallback(() => {\n        smilesArray.forEach((smi, idx) => {\n          try {\n            const mol = RDKit.get_mol(smi);\n            const canon = mol.get_smiles();\n            mol.delete();\n            inputCanonMap.set(canon, smi);\n            inputNameMap.set(canon, namesArray[idx]);\n          } catch {\n            console.warn(\"Invalid SMILES:\", smi);\n          }\n        });\n        resolve();\n      });\n    });\n\n    let combinedResults: MatchResult[] = [];\n    console.log(inputData)\n    // Helper to append expert params\n    const appendExpertParams = (query: URLSearchParams) => {\n      if (!inputData.config) return;\n      if (typeof inputData.config.excludeMolProps === \"boolean\")\n        query.append(\"ExcludeMolProp\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      if (typeof inputData.config.strictMode === \"boolean\")\n        query.append(\"strict_error\", inputData.config.strictMode ? \"true\" : \"false\");\n      if (typeof inputData.config.uniqueAtoms === \"boolean\")\n        query.append(\"unique_set\", inputData.config.uniqueAtoms ? \"true\" : \"false\");\n      if (typeof inputData.config.kekule === \"boolean\")\n        query.append(\"kekuleSmiles\", inputData.config.kekule ? \"true\" : \"false\");\n      if (typeof inputData.config.isomeric === \"boolean\")\n        query.append(\"isomericSmiles\", inputData.config.isomeric ? \"true\" : \"false\");\n      if (typeof inputData.config.non_zero_row === \"boolean\")\n          query.append(\"only_rows\", inputData.config.non_zero_row ? \"true\" : \"false\");\n    };\n\n    // PAINS Filter API call (only excludeMolProps)\n    if (runmode === \"filter\" && painsIsChecked) {\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      if (inputData.config?.excludeMolProps) {\n        query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      }\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n      const json = await res.json();\n\n      json.results.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.reasons.join(\", \"),\n            matched: entry.failed,\n            failed: entry.failed,\n            highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n            all_pains_filters: json.all_pains_filters,\n            matches: json.all_pains_filters.map((p: string) => entry.reasons.includes(p)),\n            filterName: \"PAINS\",\n          });\n        } catch {\n          console.warn(\"Failed to process PAINS entry:\", entry);\n        }\n      });\n    }\n\n    // BLAKE Filter API call with expert params\n    if (runmode === \"filter\" && blakeIsChecked) {\n      const smartsText = await fetch(\"/data/ursu_pains.sma\").then((res) => res.text());\n      const smartsPatterns = smartsText\n        .split(/\\r?\\n/)\n        .filter((line) => line.trim().length > 0)\n        .map((line) => {\n          const parts = line.trim().split(/\\s+/);\n          return { smarts: parts[0], name: parts[1] || \"unknown\" };\n        });\n\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      smartsPatterns.forEach((s) => {\n        query.append(\"smarts\", s.smarts);\n        query.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(query);\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n      const json = await res.json();\n\n      json.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans: boolean[] = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: smartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"BLAKE\",\n          });\n        } catch {\n          console.warn(\"Failed to process BLAKE entry:\", entry);\n        }\n      });\n    }\n\n    // Expert Custom SMARTS mode\n    if (isExpert && inputData.smarts?.content?.trim()) {\n      let smartsRaw = \"\";\n      if (inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n\n      const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter((line: string) => line.trim().length > 0);\n      const customSmartsPatterns = customSmartsLines.map((line: string) => {\n        const parts = line.trim().split(/\\s+/);\n        return { smarts: parts[0], name: parts[1] || \"custom\" };\n      });\n\n      const expertQuery = new URLSearchParams();\n      expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n      expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n      customSmartsPatterns.forEach((s) => {\n        expertQuery.append(\"smarts\", s.smarts);\n        expertQuery.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(expertQuery);\n\n      const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n      const expertJson = await expertRes.json();\n\n      expertJson.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: customSmartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"CUSTOM\",\n          });\n        } catch {\n          console.warn(\"Failed to process EXPERT entry:\", entry);\n        }\n      });\n    }\n\n    combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n    setResults(combinedResults);\n  } finally {\n    setIsSubmitting(false);\n  }\n};\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      setPainsChecked={setPainsChecked}\n      batch={batch}\n      view={view}\n      includePasses={includePasses}\n      setIncludePasses={setIncludePasses}\n      includeFails={includeFails}\n      setIncludeFails={setIncludeFails}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        includePasses={includePasses}\n        includeFails={includeFails}\n      />\n    </SmartFilterLayout>\n  );\n}\n\nexport default HomePage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}