{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction HomePage() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n  const [errorMessage, setErrorMessage] = useState([]);\n  const addError = msg => {\n    setErrorMessage(prev => [...prev, msg]);\n  };\n  const safeFetch = async url => {\n    const res = await fetch(url);\n    if (!res.ok) {\n      addError(\"Error \" + res.status + res.statusText);\n      return null;\n    }\n    return res.json();\n  };\n  useEffect(() => {\n    const handler = e => {\n      var _e$reason;\n      setErrorMessage(((_e$reason = e.reason) === null || _e$reason === void 0 ? void 0 : _e$reason.message) || \"Unexpected error.\");\n    };\n    window.addEventListener(\"unhandledrejection\", handler);\n    return () => window.removeEventListener(\"unhandledrejection\", handler);\n  }, []);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      var _inputData$config$has, _inputData$config, _inputData$smarts, _inputData$smarts$con;\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n\n      // Skip header if hasHeader true\n      const hasHeader = (_inputData$config$has = (_inputData$config = inputData.config) === null || _inputData$config === void 0 ? void 0 : _inputData$config.hasHeader) !== null && _inputData$config$has !== void 0 ? _inputData$config$has : false;\n      let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      if (hasHeader) {\n        lines = lines.slice(1); // Skip first line (header)\n      }\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      const isExpert = mode === \"expert\";\n\n      // Cache canonical smiles and names\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch (err) {\n              addError(\"Error 400 Invalid Smiles \" + smilesArray[idx]);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      // Helper to append expert params\n      const appendExpertParams = query => {\n        if (typeof excludeMolProps === \"boolean\") query.append(\"ExcludeMolProp\", excludeMolProps ? \"true\" : \"false\");\n        if (typeof strictMode === \"boolean\") query.append(\"strict_error\", strictMode ? \"true\" : \"false\");\n        if (typeof uniqueAtoms === \"boolean\") query.append(\"unique_set\", uniqueAtoms ? \"true\" : \"false\");\n        if (typeof useKekule === \"boolean\") query.append(\"kekuleSmiles\", useKekule ? \"true\" : \"false\");\n        if (typeof useIsomeric === \"boolean\") query.append(\"isomericSmiles\", useIsomeric ? \"true\" : \"false\");\n        if (typeof non_zero_row === \"boolean\") query.append(\"only_rows\", non_zero_row ? \"true\" : \"false\");\n      };\n\n      // PAINS Filter API call (only excludeMolProps)\n      if (runmode === \"filter\" && painsIsChecked) {\n        var _inputData$config2;\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        if ((_inputData$config2 = inputData.config) !== null && _inputData$config2 !== void 0 && _inputData$config2.excludeMolProps) {\n          query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n        }\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        if (res.status !== 200) {\n          addError(\"Error\" + res.status + res.statusText);\n          return;\n        }\n        const json = await res.json();\n        json.results.forEach(entry => {\n          try {\n            var _entry$highlight_atom, _entry$highlight_atom2;\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reasons.join(\", \"),\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [],\n              all_pains_filters: json.all_pains_filters,\n              matches: json.all_pains_filters.map(p => entry.reasons.includes(p)),\n              filterName: \"PAINS\"\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      // BLAKE Filter API call with expert params\n      if (runmode === \"filter\" && blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(r => {\n          if (!r.ok) {\n            addError(\"Error\" + r.status + r.text());\n          }\n          return r.text();\n        });\n        const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"unknown\"\n          };\n        });\n        const query = new URLSearchParams();\n        query.append(\"SMILES\", smilesArray.join(\",\"));\n        query.append(\"Smile_Names\", namesArray.join(\",\"));\n        smartsPatterns.forEach(s => {\n          query.append(\"smarts\", s.smarts);\n          query.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(query);\n        const json = await safeFetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n        if (json === null) {\n          return;\n        }\n        json.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom;\n              return (_match$highlight_atom = match.highlight_atoms) !== null && _match$highlight_atom !== void 0 ? _match$highlight_atom : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: smartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"BLAKE\"\n            });\n          } catch {\n            console.warn(\"Failed to process BLAKE entry:\", entry);\n          }\n        });\n      }\n\n      // Expert Custom SMARTS mode\n      if (isExpert && (_inputData$smarts = inputData.smarts) !== null && _inputData$smarts !== void 0 && (_inputData$smarts$con = _inputData$smarts.content) !== null && _inputData$smarts$con !== void 0 && _inputData$smarts$con.trim()) {\n        let smartsRaw = \"\";\n        if (inputData.smarts.type === \"text\") {\n          smartsRaw = inputData.smarts.content;\n        } else {\n          smartsRaw = await readFileContent(inputData.smarts.content);\n        }\n        const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n        const customSmartsPatterns = customSmartsLines.map(line => {\n          const parts = line.trim().split(/\\s+/);\n          return {\n            smarts: parts[0],\n            name: parts[1] || \"custom\"\n          };\n        });\n        const expertQuery = new URLSearchParams();\n        expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n        expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n        customSmartsPatterns.forEach(s => {\n          expertQuery.append(\"smarts\", s.smarts);\n          expertQuery.append(\"Smart_Names\", s.name);\n        });\n        appendExpertParams(expertQuery);\n        const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n        const expertJson = await expertRes.json();\n        expertJson.forEach(entry => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n            const isFailed = entry.matches.some(match => match.count > 0);\n            const highlightAtomsFlat = entry.matches.flatMap(match => {\n              var _match$highlight_atom2;\n              return (_match$highlight_atom2 = match.highlight_atoms) !== null && _match$highlight_atom2 !== void 0 ? _match$highlight_atom2 : [];\n            }).flat().filter(x => typeof x === \"number\");\n            const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n            const matchBooleans = entry.matches.map(match => match.count > 0);\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.matches.filter(m => m.count > 0).map(m => m.name).join(\", \"),\n              matched: isFailed,\n              failed: isFailed,\n              highlightAtoms: uniqueHighlightAtoms,\n              all_pains_filters: customSmartsPatterns.map(p => p.name),\n              matches: matchBooleans,\n              filterName: \"CUSTOM\"\n            });\n          } catch {\n            console.warn(\"Failed to process EXPERT entry:\", entry);\n          }\n        });\n      }\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    batch: batch,\n    view: view,\n    includePasses: includePasses,\n    setIncludePasses: setIncludePasses,\n    includeFails: includeFails,\n    setIncludeFails: setIncludeFails,\n    hasHeader: hasHeader,\n    setHasHeader: setHasHeader,\n    excludeMolProps: excludeMolProps,\n    setExcludeMolProps: setExcludeMolProps,\n    strictMode: strictMode,\n    setStrictMode: setStrictMode,\n    non_zero_row: non_zero_row,\n    setNonZeroRows: setNonZeroRows,\n    uniqueAtoms: uniqueAtoms,\n    setUniqueAtoms: setUniqueAtoms,\n    useKekule: useKekule,\n    setUseKekule: setUseKekule,\n    useIsomeric: useIsomeric,\n    setUseIsomeric: setUseIsomeric,\n    errorMessage: errorMessage,\n    setErrorMessage: setErrorMessage,\n    children: [/*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view,\n      includePasses: includePasses,\n      includeFails: includeFails\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 360,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n      style: {\n        display: \"flex\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        gap: \"10px\",\n        padding: \"10px\"\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/logo.png\",\n        alt: \"RDKit Logo\",\n        style: {\n          height: \"auto\",\n          width: \"auto\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 379,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 369,\n      columnNumber: 6\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 329,\n    columnNumber: 5\n  }, this);\n}\n_s(HomePage, \"gJQcl7eNsSheW24PH63ejiTbIZk=\");\n_c = HomePage;\nexport default HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","HomePage","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","isSubmitting","setIsSubmitting","includePasses","setIncludePasses","includeFails","setIncludeFails","hasHeader","setHasHeader","excludeMolProps","setExcludeMolProps","strictMode","setStrictMode","non_zero_row","setNonZeroRows","uniqueAtoms","setUniqueAtoms","useKekule","setUseKekule","useIsomeric","setUseIsomeric","errorMessage","setErrorMessage","addError","msg","prev","safeFetch","url","res","fetch","ok","status","statusText","json","handler","e","_e$reason","reason","message","window","addEventListener","removeEventListener","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","_inputData$config$has","_inputData$config","_inputData$smarts","_inputData$smarts$con","smilesRaw","smiles","type","content","config","lines","split","filter","Boolean","slice","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","isExpert","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","combinedResults","appendExpertParams","query","append","_inputData$config2","URLSearchParams","join","entry","_entry$highlight_atom","_entry$highlight_atom2","name","SMILES","get","Smart","reasons","matched","failed","highlightAtoms","highlight_atoms","flat","all_pains_filters","matches","map","p","filterName","warn","smartsText","then","r","text","smartsPatterns","trim","smarts","s","isFailed","some","match","count","highlightAtomsFlat","flatMap","_match$highlight_atom","x","uniqueHighlightAtoms","Array","from","Set","matchBooleans","m","smartsRaw","customSmartsLines","customSmartsPatterns","expertQuery","expertRes","expertJson","_match$highlight_atom2","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","style","display","flexDirection","alignItems","justifyContent","gap","padding","src","alt","height","width","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n  all_pains_filters?: string[];\n  filterName?: string;\n};\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nfunction HomePage() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(true);\n  const [view, setView] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [includePasses, setIncludePasses] = useState(true);\n  const [includeFails, setIncludeFails] = useState(true);\n  // Expert mode configs\n  const [hasHeader, setHasHeader] = useState(false);\n  const [excludeMolProps, setExcludeMolProps] = useState(false);\n  const [strictMode, setStrictMode] = useState(false);\n  const [non_zero_row, setNonZeroRows] = useState(false);\n  const [uniqueAtoms, setUniqueAtoms] = useState(false);\n\n  // // New expert mode input checkboxes\n  const [useKekule, setUseKekule] = useState(false);\n  const [useIsomeric, setUseIsomeric] = useState(false);\n  const [errorMessage, setErrorMessage] = useState<string[]>([]);\n  const addError = (msg: string) => {\n  setErrorMessage((prev) => [...prev, msg]);\n};\n\n\n  const safeFetch = async (url: string) => {\n    const res = await fetch(url);\n    if (!res.ok) {\n      addError(\"Error \"+res.status+res.statusText);\n      return null;\n    }\n    return res.json();\n  };\n  useEffect(() => {\n    const handler = (e: PromiseRejectionEvent) => {\n      setErrorMessage(e.reason?.message || \"Unexpected error.\");\n    };\n    window.addEventListener(\"unhandledrejection\", handler);\n    return () => window.removeEventListener(\"unhandledrejection\", handler);\n  }, []);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\nconst handleSubmit = async (inputData: any) => {\n  if (isSubmitting) return;\n  setIsSubmitting(true);\n\n  try {\n    let smilesRaw = \"\";\n    if (inputData.smiles.type === \"text\") {\n      smilesRaw = inputData.smiles.content;\n    } else {\n      smilesRaw = await readFileContent(inputData.smiles.content);\n    }\n\n    // Skip header if hasHeader true\n    const hasHeader = inputData.config?.hasHeader ?? false;\n    let lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n    if (hasHeader) {\n      lines = lines.slice(1); // Skip first line (header)\n    }\n\n    const smilesArray: string[] = [];\n    const namesArray: string[] = [];\n    for (const line of lines) {\n      const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n      const smile = parts[inputData.smileCol] || \"\";\n      smilesArray.push(smile);\n      namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n    }\n\n    setMatch(smilesArray.length);\n    const painsIsChecked = inputData.filters.includes(\"Pains\");\n    const blakeIsChecked = inputData.filters.includes(\"Blake\");\n    const isExpert = mode === \"expert\";\n\n    // Cache canonical smiles and names\n    const inputCanonMap = new Map<string, string>();\n    const inputNameMap = new Map<string, string>();\n    \n    await new Promise<void>((resolve) => {\n      requestIdleCallback(() => {\n        smilesArray.forEach((smi, idx) => {\n          try {\n            const mol = RDKit.get_mol(smi);\n            const canon = mol.get_smiles();\n            mol.delete();\n            inputCanonMap.set(canon, smi);\n            inputNameMap.set(canon, namesArray[idx]);\n          } catch(err) {\n            addError(\"Error 400 Invalid Smiles \"+smilesArray[idx]);\n          }\n        });\n        resolve();\n      });\n    });\n\n    let combinedResults: MatchResult[] = [];\n    // Helper to append expert params\n    const appendExpertParams = (query: URLSearchParams) => {\n      if (typeof excludeMolProps === \"boolean\")\n        query.append(\"ExcludeMolProp\", excludeMolProps ? \"true\" : \"false\");\n      if (typeof strictMode === \"boolean\")\n        query.append(\"strict_error\", strictMode ? \"true\" : \"false\");\n      if (typeof uniqueAtoms === \"boolean\")\n        query.append(\"unique_set\", uniqueAtoms ? \"true\" : \"false\");\n      if (typeof useKekule === \"boolean\")\n        query.append(\"kekuleSmiles\", useKekule ? \"true\" : \"false\");\n      if (typeof useIsomeric === \"boolean\")\n        query.append(\"isomericSmiles\", useIsomeric ? \"true\" : \"false\");\n      if (typeof non_zero_row === \"boolean\")\n          query.append(\"only_rows\", non_zero_row ? \"true\" : \"false\");\n    };\n\n    // PAINS Filter API call (only excludeMolProps)\n    if (runmode === \"filter\" && painsIsChecked) {\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      if (inputData.config?.excludeMolProps) {\n        query.append(\"exclude_molprops\", inputData.config.excludeMolProps ? \"true\" : \"false\");\n      }\n\n      const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n      if(res.status !==200){\n        addError(\"Error\"+res.status+res.statusText)\n        return;\n      }\n      const json = await res.json();\n      json.results.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.reasons.join(\", \"),\n            matched: entry.failed,\n            failed: entry.failed,\n            highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n            all_pains_filters: json.all_pains_filters,\n            matches: json.all_pains_filters.map((p: string) => entry.reasons.includes(p)),\n            filterName: \"PAINS\",\n          });\n        } catch {\n          console.warn(\"Failed to process PAINS entry:\", entry);\n        }\n      });\n    }\n\n    // BLAKE Filter API call with expert params\n    if (runmode === \"filter\" && blakeIsChecked) {\n      const smartsText = await fetch(\"/data/ursu_pains.sma\").then(r => {\n        if (!r.ok) {\n          addError(\"Error\"+r.status+r.text())\n        }\n        return r.text();\n      });\n      \n      const smartsPatterns = smartsText\n        .split(/\\r?\\n/)\n        .filter((line) => line.trim().length > 0)\n        .map((line) => {\n          const parts = line.trim().split(/\\s+/);\n          return { smarts: parts[0], name: parts[1] || \"unknown\" };\n        });\n\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n      smartsPatterns.forEach((s) => {\n        query.append(\"smarts\", s.smarts);\n        query.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(query);\n\n      const json = await safeFetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${query}`);\n      if(json === null){\n        return;\n      }\n      json.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans: boolean[] = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: smartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"BLAKE\",\n          });\n        } catch {\n          console.warn(\"Failed to process BLAKE entry:\", entry);\n        }\n      });\n    }\n\n    // Expert Custom SMARTS mode\n    if (isExpert && inputData.smarts?.content?.trim()) {\n      let smartsRaw = \"\";\n      if (inputData.smarts.type === \"text\") {\n        smartsRaw = inputData.smarts.content;\n      } else {\n        smartsRaw = await readFileContent(inputData.smarts.content);\n      }\n\n      const customSmartsLines = smartsRaw.split(/\\r?\\n/).filter((line: string) => line.trim().length > 0);\n      const customSmartsPatterns = customSmartsLines.map((line: string) => {\n        const parts = line.trim().split(/\\s+/);\n        return { smarts: parts[0], name: parts[1] || \"custom\" };\n      });\n\n      const expertQuery = new URLSearchParams();\n      expertQuery.append(\"SMILES\", smilesArray.join(\",\"));\n      expertQuery.append(\"Smile_Names\", namesArray.join(\",\"));\n      customSmartsPatterns.forEach((s) => {\n        expertQuery.append(\"smarts\", s.smarts);\n        expertQuery.append(\"Smart_Names\", s.name);\n      });\n      appendExpertParams(expertQuery);\n\n      const expertRes = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchcounts?${expertQuery}`);\n      const expertJson = await expertRes.json();\n      expertJson.forEach((entry: any) => {\n        try {\n          const mol = RDKit.get_mol(entry.smiles);\n          const canon = mol.get_smiles();\n          mol.delete();\n\n          const isFailed = entry.matches.some((match: any) => match.count > 0);\n          const highlightAtomsFlat: number[] = entry.matches\n            .flatMap((match: any) => match.highlight_atoms ?? [])\n            .flat()\n            .filter((x: number): x is number => typeof x === \"number\");\n          const uniqueHighlightAtoms = Array.from(new Set(highlightAtomsFlat));\n          const matchBooleans = entry.matches.map((match: any) => match.count > 0);\n\n          combinedResults.push({\n            name: entry.name,\n            SMILES: inputCanonMap.get(canon) || canon,\n            Smart: entry.matches\n              .filter((m: any) => m.count > 0)\n              .map((m: any) => m.name)\n              .join(\", \"),\n            matched: isFailed,\n            failed: isFailed,\n            highlightAtoms: uniqueHighlightAtoms,\n            all_pains_filters: customSmartsPatterns.map((p) => p.name),\n            matches: matchBooleans,\n            filterName: \"CUSTOM\",\n          });\n        } catch {\n          console.warn(\"Failed to process EXPERT entry:\", entry);\n        }\n      });\n    }\n\n    combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n    setResults(combinedResults);\n  } finally {\n    setIsSubmitting(false);\n  }\n};\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit}\n      setBatch={setBatch}\n      setView={setView}\n      batch={batch}\n      view={view}\n      includePasses={includePasses}\n      setIncludePasses={setIncludePasses}\n      includeFails={includeFails}\n      setIncludeFails={setIncludeFails}\n      hasHeader = {hasHeader}\n      setHasHeader={setHasHeader}\n      excludeMolProps={excludeMolProps}\n      setExcludeMolProps={setExcludeMolProps}\n      strictMode={strictMode}\n      setStrictMode={setStrictMode}\n      non_zero_row={non_zero_row}\n      setNonZeroRows={setNonZeroRows}\n      uniqueAtoms={uniqueAtoms}\n      setUniqueAtoms={setUniqueAtoms}\n      useKekule={useKekule}\n      setUseKekule={setUseKekule}\n      useIsomeric={useIsomeric}\n      setUseIsomeric={setUseIsomeric}\n      errorMessage={errorMessage}\n      setErrorMessage={setErrorMessage}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n        includePasses={includePasses}\n        includeFails={includeFails}\n      />\n     <footer\n      style={{\n        display: \"flex\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        gap: \"10px\",\n        padding: \"10px\",\n      }}\n    >\n      <img\n        src=\"/logo.png\"\n        alt=\"RDKit Logo\"\n        style={{ height: \"auto\", width: \"auto\" }}\n      />\n    </footer>\n    </SmartFilterLayout>\n    \n  );\n}\n\nexport default HomePage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}