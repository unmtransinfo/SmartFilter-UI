{"ast":null,"code":"var _jsxFileName = \"/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction HomePage() {\n  _s();\n  const [results, setResults] = useState([]);\n  const [mode, setMode] = useState(\"normal\");\n  const [runmode, setRunmode] = useState(\"filter\");\n  const [tMatch, setMatch] = useState(0);\n  const [RDKit, setRDKit] = useState(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\"\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n  const readFileContent = file => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      var _e$target;\n      return resolve((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n  const handleSubmit = async inputData => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    try {\n      let smilesRaw = \"\";\n      if (inputData.smiles.type === \"text\") {\n        smilesRaw = inputData.smiles.content;\n      } else {\n        smilesRaw = await readFileContent(inputData.smiles.content);\n      }\n      const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n      const smilesArray = [];\n      const namesArray = [];\n      for (const line of lines) {\n        const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n        const smile = parts[inputData.smileCol] || \"\";\n        smilesArray.push(smile);\n        namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n      }\n      setMatch(smilesArray.length);\n      const painsIsChecked = inputData.filters.includes(\"Pains\");\n      const blakeIsChecked = inputData.filters.includes(\"Blake\");\n      setPainsChecked(painsIsChecked);\n      const inputCanonMap = new Map();\n      const inputNameMap = new Map();\n      await new Promise(resolve => {\n        requestIdleCallback(() => {\n          smilesArray.forEach((smi, idx) => {\n            try {\n              const mol = RDKit.get_mol(smi);\n              const canon = mol.get_smiles();\n              mol.delete();\n              inputCanonMap.set(canon, smi);\n              inputNameMap.set(canon, namesArray[idx]);\n            } catch {\n              console.warn(\"Invalid SMILES:\", smi);\n            }\n          });\n          resolve();\n        });\n      });\n      let combinedResults = [];\n      const query = new URLSearchParams();\n      query.append(\"SMILES\", smilesArray.join(\",\"));\n      query.append(\"Smile_Names\", namesArray.join(\",\"));\n\n      // ===== FILTER MODE =====\n      if (runmode === \"filter\") {\n        if (painsIsChecked) {\n          const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n          const json = await res.json();\n          json.results.forEach(entry => {\n            try {\n              var _entry$highlight_atom, _entry$highlight_atom2;\n              const mol = RDKit.get_mol(entry.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n              const patternMatches = {};\n              json.all_pains_filters.forEach(patternName => {\n                patternMatches[patternName] = entry.reasons.includes(patternName);\n              });\n              combinedResults.push({\n                name: entry.name,\n                SMILES: inputCanonMap.get(canon) || canon,\n                Smart: entry.reasons.join(\", \"),\n                matched: entry.failed,\n                failed: entry.failed,\n                highlightAtoms: (_entry$highlight_atom = (_entry$highlight_atom2 = entry.highlight_atoms) === null || _entry$highlight_atom2 === void 0 ? void 0 : _entry$highlight_atom2.flat()) !== null && _entry$highlight_atom !== void 0 ? _entry$highlight_atom : [],\n                all_pains_filters: json.all_pains_filters,\n                matches: json.all_pains_filters.map(p => entry.reasons.includes(p)),\n                filterName: \"PAINS\"\n              });\n            } catch {\n              console.warn(\"Failed to process PAINS entry:\", entry);\n            }\n          });\n        }\n        if (blakeIsChecked) {\n          var _json$failed, _json$passed;\n          const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n          const smartsPatterns = smartsText.split(/\\r?\\n/).filter(line => line.trim().length > 0).map(line => {\n            const parts = line.trim().split(/\\s+/);\n            return {\n              smarts: parts[0],\n              name: parts[1] || \"unknown\"\n            };\n          });\n          console.log(smartsPatterns);\n          // Append all smarts and names to query if needed (optional)\n          smartsPatterns.forEach(s => {\n            query.append(\"smarts\", s.smarts);\n            query.append(\"Smart_Names\", s.name);\n          });\n          const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchfilter?${query}`);\n          const json = await res.json();\n\n          // Collect all molecules (failed + passed) keyed by smiles\n          const molMap = new Map();\n          (_json$failed = json.failed) === null || _json$failed === void 0 ? void 0 : _json$failed.forEach(entry => {\n            molMap.set(entry.smiles, {\n              ...entry,\n              failed: true\n            });\n          });\n          (_json$passed = json.passed) === null || _json$passed === void 0 ? void 0 : _json$passed.forEach(entry => {\n            if (!molMap.has(entry.smiles)) {\n              molMap.set(entry.smiles, {\n                ...entry,\n                failed: false\n              });\n            }\n          });\n          molMap.forEach(entry => {\n            try {\n              var _entry$highlight_atom3, _entry$highlight_atom4;\n              const mol = RDKit.get_mol(entry.smiles);\n              const canon = mol.get_smiles();\n              mol.delete();\n\n              // Build boolean array for each pattern: true if matched, false otherwise\n              const matchesArray = smartsPatterns.map(pattern => {\n                // If your API returns 'reasons' array use it, else single 'reason' string\n                if (entry.reasons && Array.isArray(entry.reasons)) {\n                  return entry.reasons.includes(pattern.name);\n                }\n                return entry.reason === pattern.name;\n              });\n              combinedResults.push({\n                name: entry.name,\n                SMILES: inputCanonMap.get(canon) || canon,\n                failed: entry.failed,\n                highlightAtoms: (_entry$highlight_atom3 = (_entry$highlight_atom4 = entry.highlight_atoms) === null || _entry$highlight_atom4 === void 0 ? void 0 : _entry$highlight_atom4.flat()) !== null && _entry$highlight_atom3 !== void 0 ? _entry$highlight_atom3 : [],\n                all_pains_filters: smartsPatterns.map(p => p.name),\n                matches: matchesArray,\n                filterName: \"Blake\"\n              });\n            } catch (e) {\n              console.warn(\"Error processing Blake molecule\", e);\n            }\n          });\n        }\n      }\n      combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n      setResults(combinedResults);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SmartFilterLayout, {\n    mode: mode,\n    setMode: setMode,\n    runmode: runmode,\n    setRunmode: setRunmode,\n    onSubmit: handleSubmit,\n    setBatch: setBatch,\n    setView: setView,\n    setPainsChecked: setPainsChecked,\n    view: view,\n    children: /*#__PURE__*/_jsxDEV(SmartsFilterResult, {\n      matchCounts: results,\n      mode: runmode,\n      totalMatched: tMatch,\n      batch: batch,\n      view: view\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 214,\n    columnNumber: 5\n  }, this);\n}\n_s(HomePage, \"ZVeM/VDWQEHu6bfUEueg8WUZAyM=\");\n_c = HomePage;\nexport default HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");","map":{"version":3,"names":["React","useEffect","useState","SmartFilterLayout","SmartsFilterResult","initRDKitModule","jsxDEV","_jsxDEV","HomePage","_s","results","setResults","mode","setMode","runmode","setRunmode","tMatch","setMatch","RDKit","setRDKit","batch","setBatch","view","setView","depict","setDepict","painsChecked","setPainsChecked","isSubmitting","setIsSubmitting","loadRDKit","RDKitModule","locateFile","console","log","err","error","readFileContent","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","target","result","onerror","readAsText","handleSubmit","inputData","smilesRaw","smiles","type","content","lines","split","filter","Boolean","smilesArray","namesArray","line","parts","RegExp","delimiter","smile","smileCol","push","nameCol","length","painsIsChecked","filters","includes","blakeIsChecked","inputCanonMap","Map","inputNameMap","requestIdleCallback","forEach","smi","idx","mol","get_mol","canon","get_smiles","delete","set","warn","combinedResults","query","URLSearchParams","append","join","res","fetch","json","entry","_entry$highlight_atom","_entry$highlight_atom2","patternMatches","all_pains_filters","patternName","reasons","name","SMILES","get","Smart","matched","failed","highlightAtoms","highlight_atoms","flat","matches","map","p","filterName","_json$failed","_json$passed","smartsText","then","text","smartsPatterns","trim","smarts","s","molMap","passed","has","_entry$highlight_atom3","_entry$highlight_atom4","matchesArray","pattern","Array","isArray","reason","sort","a","b","Number","onSubmit","children","matchCounts","totalMatched","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/bspanthi/Documents/SmartFilter-UI/smarts-filter-ui/src/HomePage.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport SmartFilterLayout from \"./components/SmartFilterLayout\";\nimport SmartsFilterResult from \"./components/SmartsFilterResult\";\nimport initRDKitModule from \"@rdkit/rdkit\";\n\nexport type MatchResult = {\n  name: string;\n  SMILES: string;\n  Smart?: string;\n  n_matches?: number;\n  matched?: boolean;\n  matches?: boolean[];\n  failed?: boolean;\n  highlightAtoms?: number[];\n  all_pains_filters?: string[];\n  filterName?: string;\n};\n\nexport type RunMode = \"filter\" | \"analyze1mol\";\nexport type AppMode = \"normal\" | \"expert\";\n\nfunction HomePage() {\n  const [results, setResults] = useState<MatchResult[]>([]);\n  const [mode, setMode] = useState<AppMode>(\"normal\");\n  const [runmode, setRunmode] = useState<RunMode>(\"filter\");\n  const [tMatch, setMatch] = useState<number>(0);\n  const [RDKit, setRDKit] = useState<any>(null);\n  const [batch, setBatch] = useState(false);\n  const [view, setView] = useState(false);\n  const [depict, setDepict] = useState(false);\n  const [painsChecked, setPainsChecked] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  useEffect(() => {\n    const loadRDKit = async () => {\n      try {\n        const RDKitModule = await initRDKitModule({\n          locateFile: () => \"/RDKit_minimal.wasm\",\n        });\n        setRDKit(RDKitModule);\n        console.log(\"RDKit.js initialized in App\");\n      } catch (err) {\n        console.error(\"RDKit.js init failed\", err);\n      }\n    };\n    loadRDKit();\n  }, []);\n\n  const readFileContent = (file: File): Promise<string> =>\n    new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = reject;\n      reader.readAsText(file);\n    });\n\nconst handleSubmit = async (inputData: any) => {\n  if (isSubmitting) return;\n  setIsSubmitting(true);\n\n  try {\n    let smilesRaw = \"\";\n    if (inputData.smiles.type === \"text\") {\n      smilesRaw = inputData.smiles.content;\n    } else {\n      smilesRaw = await readFileContent(inputData.smiles.content);\n    }\n\n    const lines = smilesRaw.split(/\\r?\\n/).filter(Boolean);\n    const smilesArray: string[] = [];\n    const namesArray: string[] = [];\n    for (const line of lines) {\n      const parts = line.split(new RegExp(`[\\t,${inputData.delimiter}]+`)).filter(Boolean);\n      const smile = parts[inputData.smileCol] || \"\";\n      smilesArray.push(smile);\n      namesArray.push(inputData.nameCol !== null && parts[inputData.nameCol] ? parts[inputData.nameCol] : smile);\n    }\n\n    setMatch(smilesArray.length);\n    const painsIsChecked = inputData.filters.includes(\"Pains\");\n    const blakeIsChecked = inputData.filters.includes(\"Blake\");\n    setPainsChecked(painsIsChecked);\n\n    const inputCanonMap = new Map<string, string>();\n    const inputNameMap = new Map<string, string>();\n\n    await new Promise<void>((resolve) => {\n      requestIdleCallback(() => {\n        smilesArray.forEach((smi, idx) => {\n          try {\n            const mol = RDKit.get_mol(smi);\n            const canon = mol.get_smiles();\n            mol.delete();\n            inputCanonMap.set(canon, smi);\n            inputNameMap.set(canon, namesArray[idx]);\n          } catch {\n            console.warn(\"Invalid SMILES:\", smi);\n          }\n        });\n        resolve();\n      });\n    });\n\n    let combinedResults: MatchResult[] = [];\n    const query = new URLSearchParams();\n    query.append(\"SMILES\", smilesArray.join(\",\"));\n    query.append(\"Smile_Names\", namesArray.join(\",\"));\n\n    // ===== FILTER MODE =====\n    if (runmode === \"filter\") {\n      if (painsIsChecked) {\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_filterpains?${query}`);\n        const json = await res.json();\n\n        json.results.forEach((entry: any) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n\n            const patternMatches: { [pattern: string]: boolean } = {};\n            json.all_pains_filters.forEach((patternName: string) => {\n              patternMatches[patternName] = entry.reasons.includes(patternName);\n            });\n\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              Smart: entry.reasons.join(\", \"),\n              matched: entry.failed,\n              failed: entry.failed,\n              highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n              all_pains_filters: json.all_pains_filters,\n              matches: json.all_pains_filters.map(\n                (p: string) => entry.reasons.includes(p)\n              ),\n              filterName: \"PAINS\",\n            });\n          } catch {\n            console.warn(\"Failed to process PAINS entry:\", entry);\n          }\n        });\n      }\n\n      if (blakeIsChecked) {\n        const smartsText = await fetch(\"/data/ursu_pains.sma\").then(res => res.text());\n        const smartsPatterns = smartsText\n          .split(/\\r?\\n/)\n          .filter(line => line.trim().length > 0)\n          .map(line => {\n            const parts = line.trim().split(/\\s+/);\n            return { smarts: parts[0], name: parts[1] || \"unknown\" };\n          });\n        console.log(smartsPatterns);\n        // Append all smarts and names to query if needed (optional)\n        smartsPatterns.forEach((s) => {\n          query.append(\"smarts\", s.smarts);\n          query.append(\"Smart_Names\", s.name);\n        });\n\n        const res = await fetch(`http://localhost:8000/api/v1/smarts_filter/get_multi_matchfilter?${query}`);\n        const json = await res.json();\n\n        // Collect all molecules (failed + passed) keyed by smiles\n        const molMap = new Map<string, any>();\n        json.failed?.forEach((entry: any) => {\n          molMap.set(entry.smiles, { ...entry, failed: true });\n        });\n        json.passed?.forEach((entry: any) => {\n          if (!molMap.has(entry.smiles)) {\n            molMap.set(entry.smiles, { ...entry, failed: false });\n          }\n        });\n\n        molMap.forEach((entry) => {\n          try {\n            const mol = RDKit.get_mol(entry.smiles);\n            const canon = mol.get_smiles();\n            mol.delete();\n\n            // Build boolean array for each pattern: true if matched, false otherwise\n            const matchesArray = smartsPatterns.map((pattern) => {\n              // If your API returns 'reasons' array use it, else single 'reason' string\n              if (entry.reasons && Array.isArray(entry.reasons)) {\n                return entry.reasons.includes(pattern.name);\n              }\n              return entry.reason === pattern.name;\n            });\n\n            combinedResults.push({\n              name: entry.name,\n              SMILES: inputCanonMap.get(canon) || canon,\n              failed: entry.failed,\n              highlightAtoms: entry.highlight_atoms?.flat() ?? [],\n              all_pains_filters: smartsPatterns.map((p) => p.name),\n              matches: matchesArray,\n              filterName: \"Blake\",\n            });\n          } catch (e) {\n            console.warn(\"Error processing Blake molecule\", e);\n          }\n        });\n      }\n    }\n    combinedResults.sort((a, b) => Number(b.failed) - Number(a.failed));\n    setResults(combinedResults);\n  } finally {\n    setIsSubmitting(false);\n  }\n};\n\n\n  return (\n    <SmartFilterLayout\n      mode={mode}\n      setMode={setMode}\n      runmode={runmode}\n      setRunmode={setRunmode}\n      onSubmit={handleSubmit} \n      setBatch={setBatch}\n      setView={setView}\n      setPainsChecked={setPainsChecked}\n      view={view}\n    >\n      <SmartsFilterResult\n        matchCounts={results}\n        mode={runmode}\n        totalMatched={tMatch}\n        batch={batch}\n        view={view}\n      />\n    </SmartFilterLayout>\n  );\n}\nexport default HomePage;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}